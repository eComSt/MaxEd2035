# Магические методы

# Введение в магические методы

# Создаем класс для моделирования машины
class Car:
    # инициализатор класса
    def __init__(self, color, model, speed):
        self.color = color  # цвет
        self.model = model  # модель
        self.speed = speed  # скорость

my_car = Car('Белый', 'Camry', 100)     # создаем объект класса Car 
print(my_car)                           # выводим адрес объекта в терминал
print(my_car.__dict__)                  # получаем локальные свойства объекта

# ----------------------------------------------------------------------------

# Метод __new__()

# Создаем класс для моделирования машины
class Car:
    # метод __new__(), итоговая версия
    def __new__(cls, *args, **kwargs):
        print(f'Работает метод __new__() для класса {cls}')
        # print(args)
        # print(kwargs)
        return super().__new__(cls)  # возвращаем новый, неинициализированный объект

    # инициализатор класса
    def __init__(self, color, model, speed):
        self.color = color  # цвет
        self.model = model  # модель
        self.speed = speed  # скорость

my_car = Car('Белый', 'Camry', 100)     # создаем объект класса Car 
# создаем объект класса Car с именованными аргументами
my_car = Car(color='Белый', model='Camry', speed=100)   
print(my_car)                           # выводим адрес объекта в терминал

# ----------------------------------------------------------------------------

# Шаблон проектирования Singleton

# Создаем класс для моделирования капитана команды
class Captain:
    __cap = None    # ссылка на экземпляр класса Captain
    # метод __new__(), итоговая версия
    def __new__(cls, *args, **kwargs):
        if cls.__cap is None:                   # если объекта класса Captain еще нет в программе
            cls.__cap = super().__new__(cls)    # создаем объект класса Captain
        return cls.__cap                        # возвращаем созданный объект

    # инициализатор класса
    def __init__(self, name, age, height, weight):
        self.name = name        # имя
        self.age = age          # возраст
        self.height = height    # рост
        self.weight = weight    # масса

# создаем экземпляр класса Captain
cap = Captain(name='Дима', age=26, height=179, weight=75)
# пытаемся создать новый экземпляр класса Captain
new_cap = Captain(name='Миша', age=25, height=189, weight=82)

# выводим адреса созданных объектов на экран (они совпадают)
print(cap)
print(new_cap)

# выводим локальные свойства созданных объектов на экран (они совпадают)
print(cap.__dict__)
print(new_cap.__dict__)

# Описанный выше класса является частичной реализацией шаблона проектирования Singleton - "Одиночка"

# ----------------------------------------------------------------------------

# Методы __str__() и __repr__()

# Создаем упрощенную версию класса для моделирования машины
class Car:
    # инициализатор класса
    def __init__(self, model):
        self.model = model  # модель
    
    # метод для отображения информации об объекте в понятном для пользователя виде
    def __str__(self):
        return f'Модель машины - {self.model}'
    
    # метод для отображения информации об объекте в понятном для разработчика виде
    def __repr__(self):
        return f'Car({self.model})'

my_car = Car('Camry')   # создаем объект класса Car 
print(my_car)           # выводим информацию об объекте в терминал (вызов метода __str__())
print(repr(my_car))     # выводим информацию об объекте в терминал (вызов метода __repr__())

# ----------------------------------------------------------------------------

# Магические методы арифметических операций

# Создаем класс для описания копилки
class MoneyBox:
    # инициализатор класса
    def __init__(self, money=0):
        self.__money = money    # текущее количество денег

    # возвращает текущее количество денег в виде строки
    def __repr__(self):
        return f'{self.__money}'

    # метод для реализации добавления денег в копилку
    def __add__(self, other):
        # проверка, что пытаемся сложить с целым или дробным числом
        if isinstance(other, (int, float)):
            # создаем новый объект класса MoneyBox с увеличенным количеством денег
            return MoneyBox(self.__money + other)
        # если пытаемся сложить не с целым или дробным числом
        else:
            # выводим информацию о некорректном сложении
            print('Некорректное сложение')
    
    # зеркальный метод для __add__(), нужен для сложения с любым порядком операндов
    def __radd__(self, other):
        # вызываем метод __add__() с переставленными операндами
        return self.__add__(other)


box = MoneyBox(123)     # создаем объект класса MoneyBox
box = box + 10          # добавляем деньги в копилку
box += 10               # складываем в сокращенной форме
box += 10.56            # складываем с дробным числом
box += '10'             # пытаемся сложить объект box со строкой (ошибка)
box = 10 + box          # меняем операнды в выражении
print(box)              # выводим на экран текущее количество денег
