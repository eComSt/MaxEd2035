# Декораторы I

'''
Декоратор – это функция, которая позволяет модифицировать поведение других функций, не изменяя их сути. 
Они нужны для того, чтобы добавить функции новое «поведение», не захламляя ее код. 
'''

def decorator(func): # функция, декоратор, принимающая функцию func
    def wrapper():
        print('Начало работы функции')
        func()
        print('Конец работы функции')
    return wrapper

def hello():
    print('Приветствую в своей программе')

hello_message = decorator(hello) # обрабатываем функцию hello с помощью декоратора
hello_message() # вызываем функцию

'''
Процесс создания декоратора можно разбить на 3 части: 
1. Определение декоратора – функция, которая принимает другую функцию в качестве аргумента
2. Обертывание функции – внутри декоратора определяется внутренняя функция (обычно называется wrapper), 
которая будет выполнять дополнительные действия над полученной функцией
3. Возвращение новой функции – декоратор возвращает функцию wrapper, 
тем самым «оборачивая» исходную дополнительными командами. 

'''

# -----------------------------------------------------------------------------------------------------------

# Использование оператора @

@decorator # указываем декоратор, который обернет функцию снизу
def hello():
    print('Приветствую в своей программе')

hello() # вызываем функцию

# Создаем декоратор для подсчета времени выполнения кода

from time import time, sleep

def timer(func):
    def wrapper():
        start_time = time()
        func()
        end_time = time()
        print(f"Время выполнения: {end_time - start_time} секунд.")
    return wrapper

@timer # Указываем декоратор перед функцией
def unfreeze():
    sleep(10)  # Представим, что приготовление занимает 10 секунды

@timer
def get_sum():
    return [i for i in range(1, 100000000)]

unfreeze()
get_sum()

'''
Дана функция message(), которая выводит на экран «Привет!». Создайте декоратор repeat(), 
который сможет повторять функцию 10 раз (таким образом, при вызове функции message(), 
обернутой в repeat(), сообщение «Привет!» должно появиться на экране 10 раз)
'''

def repeat(func):
    def wrapper():
        for _ in range(10):
            func()
    return wrapper

@repeat # вызываем декоратор repeat
def message():
    print('Привет!')

message() # вызываем функцию message

# -----------------------------------------------------------------------------------------------------------

# Декорирование функций с входными параметрами

# Дополним предыдущую программу, чтобы она выводила «Привет, <имя>!»: 

def repeat(func):
    def wrapper(*args, **kwargs):
        for _ in range(10):
            func(*args, **kwargs) # вызываем функцию с передачей аргументов
    return wrapper

@repeat # указываем, какая функции будет обертывать message
def message(name):
    print(f'Привет, {name}!')

message('Ваня') # вызываем функцию

'''
1.	При вызове message('Ваня') вызывается wrapper('Ваня')
2.	wrapper принимает аргумент 'Ваня' с помощью (*args, **kwargs)
3.	В своем теле wrapper вызывает message(*args, **kwargs), то есть message('Ваня'), 
а также добавляет обертку, в нашем случае – повторение 10 раз
'''

# Потренируемся декорировать функцию с входными параметрами
'''
Андрей хочет с использованием декоратора access() реализовать систему прав доступа к данным. 
Для этого он придумал пароль «12345qwerty». Декоратор должен выдать сообщение «Доступ разрешен» 
и запустить функцию send_message(), если в нее передан верный пароль и написать 
«Доступ запрещен. Введен неверный пароль» в ином случае. 
'''

    
def access(func):
    def wrapper(*args, **kwagrs):
        if kwagrs.get('password') == '12345qwerty':
            return f'Доступ разрешен. {func(*args, **kwagrs)}'
        else:
            return 'Доступ запрещен. Введен неверный пароль.'
    return wrapper

@access
def send_message(message, **kwargs):
    return f'Сообщение: {message}'

user_password = input('Введите пароль:')
result = send_message('Очень важная информация!', password=user_password)
print(result)

# -----------------------------------------------------------------------------------------------------------

# Вызов нескольких декораторов

def up(func):
    def wrapper(*args, **kwagrs):
        text = func(*args, **kwagrs)
        return text.upper()
    return wrapper

def warning(func):
    def wrapper(*args, **kwagrs):
        return f'Вы получили сообщение: {func(*args, **kwagrs)}'
    return wrapper

@up
@warning
def send_message(gift):
    return f'Мне на день рождения подарили {gift}'

print(send_message('телефон'))

# При использовании нескольких декораторов, порядок выполнения определяется расположением (снизу вверх).
